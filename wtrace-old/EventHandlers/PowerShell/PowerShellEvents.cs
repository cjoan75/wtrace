using System;
using System.Diagnostics;
using System.Diagnostics.Tracing;
using System.Text;
using Microsoft.Diagnostics.Tracing;
using Address = System.UInt64;

#pragma warning disable 1591        // disable warnings on XML comments not being present

// This code was automatically generated by the TraceParserGen tool, which converts
// an ETW event manifest into strongly typed C# classes.
namespace Microsoft.Diagnostics.Tracing.Parsers
{
    using Microsoft.Diagnostics.Tracing.Parsers.MicrosoftWindowsPowerShell;

    [System.CodeDom.Compiler.GeneratedCode("traceparsergen", "2.0")]
    public sealed class MicrosoftWindowsPowerShellTraceEventParser : TraceEventParser 
    {
        public static string ProviderName = "Microsoft-Windows-PowerShell";
        public static Guid ProviderGuid = new Guid(unchecked((int) 0xa0c1853b), unchecked((short) 0x5c40), unchecked((short) 0x4b15), 0x87, 0x66, 0x3c, 0xf1, 0xc5, 0x8f, 0x98, 0x5a);
        public enum Keywords : long
        {
            Runspace = 0x1,
            Pipeline = 0x2,
            Protocol = 0x4,
            Transport = 0x8,
            Host = 0x10,
            Cmdlets = 0x20,
            Serializer = 0x40,
            Session = 0x80,
            Plugin = 0x100,
            Psworkflow = 0x200,
        };

        public MicrosoftWindowsPowerShellTraceEventParser(TraceEventSource source) : base(source) {}

        public event Action<ScriptBlockEventArgs> ScriptBlockEvent4104
        {
            add
            {
                source.RegisterEventTemplate(ScriptBlock4104EventTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 4104, ProviderGuid);
            }
        }

        public event Action<CommandEventArgs> CommandEvent4103
        {
            add
            {
                source.RegisterEventTemplate(CommandEvent4103Template(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 4103, ProviderGuid);
            }
        }

        public event Action<CommandEventArgs> CommandEvent7937
        {
            add
            {
                source.RegisterEventTemplate(CommandEvent7937Template(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 7937, ProviderGuid);
            }
        }

        protected override string GetProviderName() { return ProviderName; }

        static private ScriptBlockEventArgs ScriptBlock4104EventTemplate(Action<ScriptBlockEventArgs> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ScriptBlockEventArgs(action, 4104, 102, "StartingCommand", Guid.Empty, 15, "Oncreatecalls", ProviderGuid, ProviderName );
        }

        static private CommandEventArgs CommandEvent7937Template(Action<CommandEventArgs> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new CommandEventArgs(action, 7937, 0, "None", Guid.Empty, 20, "Tobeusedwhenoperationisjustexecutingamethod", ProviderGuid, ProviderName );
        }

        static private CommandEventArgs CommandEvent4103Template(Action<CommandEventArgs> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new CommandEventArgs(action, 4103, 0, "None", Guid.Empty, 19, "Tobeusedwhenanexceptionisraised", ProviderGuid, ProviderName );
        }

        static private volatile TraceEvent[] s_templates;
        protected override void EnumerateTemplates(Func<string, string, EventFilterResponse> eventsToObserve, Action<TraceEvent> callback)
        {
            if (s_templates == null)
            {
                var templates = new TraceEvent[3];
                templates[0] = ScriptBlock4104EventTemplate(null);
                templates[1] = CommandEvent7937Template(null);
                templates[2] = CommandEvent4103Template(null);
                s_templates = templates;
            }
            foreach (var template in s_templates)
                if (eventsToObserve == null || eventsToObserve(template.ProviderName, template.EventName) == EventFilterResponse.AcceptEvent)
                    callback(template);
        }
    }
}

namespace Microsoft.Diagnostics.Tracing.Parsers.MicrosoftWindowsPowerShell
{
    public sealed class ScriptBlockEventArgs : TraceEvent
    {
        public int MessageNumber { get { return GetInt32At(0); } }
        public int MessageTotal { get { return GetInt32At(4); } }
        public string ScriptBlockText { get { return GetUnicodeStringAt(8); } }
        public string ScriptBlockId { get { return GetUnicodeStringAt(SkipUnicodeString(8)); } }
        public string Path { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(8))); } }

        #region Private
        internal ScriptBlockEventArgs(Action<ScriptBlockEventArgs> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected override void Dispatch()
        {
            m_target(this);
        }
        protected override void Validate()
        {
            Debug.Assert(!(Version == 1 && EventDataLength != SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(8)))));
            Debug.Assert(!(Version > 1 && EventDataLength < SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(8)))));
        }
        protected override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<ScriptBlockEventArgs>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "MessageNumber", MessageNumber);
             XmlAttrib(sb, "MessageTotal", MessageTotal);
             XmlAttrib(sb, "ScriptBlockText", ScriptBlockText);
             XmlAttrib(sb, "ScriptBlockId", ScriptBlockId);
             XmlAttrib(sb, "Path", Path);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "MessageNumber", "MessageTotal", "ScriptBlockText", "ScriptBlockId", "Path"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return MessageNumber;
                case 1:
                    return MessageTotal;
                case 2:
                    return ScriptBlockText;
                case 3:
                    return ScriptBlockId;
                case 4:
                    return Path;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<ScriptBlockEventArgs> m_target;
        #endregion
    }

    public sealed class CommandEventArgs : TraceEvent
    {
        public string ContextInfo { get { return GetUnicodeStringAt(0); } }
        public string UserData { get { return GetUnicodeStringAt(SkipUnicodeString(0)); } }
        public string Payload { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(0))); } }

        #region Private
        internal CommandEventArgs(Action<CommandEventArgs> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected override void Dispatch()
        {
            m_target(this);
        }
        protected override void Validate()
        {
            Debug.Assert(!(Version == 1 && EventDataLength != SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))));
            Debug.Assert(!(Version > 1 && EventDataLength < SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))));
        }
        protected override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<CommandEventArgs>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "ContextInfo", ContextInfo);
             XmlAttrib(sb, "UserData", UserData);
             XmlAttrib(sb, "Payload", Payload);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "ContextInfo", "UserData", "Payload"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return ContextInfo;
                case 1:
                    return UserData;
                case 2:
                    return Payload;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<CommandEventArgs> m_target;
        #endregion
    }
}
